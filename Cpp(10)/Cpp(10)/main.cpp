//inline成员函数
/*
类的成员函数也可以指定为内联函数
在类体中定义成员函数的规模一般都很小，而系统调用函数的过程所花费的时间开销
相对来说是比较大的。调用一个函数的时间开销远远大于小规模函数体中全部语句的执行时间
为了减少时间开销，如果在类体中定义的成员函数不包括循环等控制结构
C++系统会自动地对他们作为内联函数来处理。也就是说，在程序调用这些成员函数的时候，并不
真正地执行函数地调用过程，而是把函数代码嵌入程序地调用点，这样可以
大大减少调用陈成员函数地开销
C++要求对一般地内置函数要用关键字inline进行修饰，但是对类内地成员函数
可以不使用inline进行修饰，因为这些成员函数已经被隐式地声明成内联函数了
*/


//应该主义的是，如果成员函数不再类体内进行定义，而是在类外进行定义的
//系统并不把他默认为内联函数，如果想把其看为内联函数，则需要
//使用inline关键字进行修饰
#include<string.h>
#include<iostream>
using namespace std;
class Student
{
public:
	inline void display()
	{

	}
private:
	int num;
	string name;
	char sex;
};
inline void Student::display()
{

}


//成员函数的存储方式
/*
用类定义对象的时候，系统会为每一个对象分配存储空间
如果一个类包括了数据成员和函数成员，那么按理来说，要分别为数据和函数代码
分配存储空间。如果用同一个类定义了10个对象，那么是否需要为每一个对象的数据和函数
代码分别分配内存单元，并且把他们封装在一起呢？
事实上不是这样的，经过分析可以知道，同一类的不同对象中的数成员的值
一般来说是不一样的，而不同对象的函数代码是相同的，不论调用哪一个对象的函数代码
其实调用的都是同样的代码内容。既然这样，在内存中开辟10个空间分别来存储10个相同
内容的函数代码段，显然是没有什么必要的
人们自然就会想了，能不能只用一段空间来存放这恶共同的函数代码
在调用的时候，都去调用这个公共的函数代码
*/


/*
显然，这样做会大大的节省空间。C++编译系统也确实是这样做的，因此每个对象所占用的存储空间只是该
对象的数据成员所占有的空间，当然了，需要考虑内存对齐的问题，而不包括函数代码所占用的存储空间
*/

class Time
{
public:
	int hour;
	int minute;
	int sec;
	void set()
	{

	}
};

//上述类的大小为12


/*
需要注意的是：虽然调用不同对象的成员函数时都是执行同一段函数代码
但是，执行的结果，一般来说是不同的
那么，就发生了一个问题：不同的对象使用的是同一个函数代码段，它
怎么能够对不同对象中的数据进行操作呢？原来C++为此专门设里了一个名为this的指针
用来指向不同的对象，当调用std1中的成员函数时，this指针就指向std1
成员函数访问的就是std1的成员，当调用std2的成员函数的时候，也是同理
*/


//需要说明的是：
/*
不论成员函数是在类内定义的还是在类外定义的，成员函数的代码段的存储方式都是
相同的，都不占用对象的存储空间
不要误以为在类内定义的成员函数就会占用对象的存储空间，而在类外
就不占用对象的存储空间

不要将成员函数的这种存储方式和inline函数的概念混淆

不论是否用inline声明函数，成员函数的代码段都不占用对象的空间
用inline声明的作用就是在调用函数时，将函数代码段复制插入到函数的调用点
而如果没有用inline声明的话，则在调用该函数的时候，流程转去函数代码段的入口地址，在
执行完函数代码后，流程返回函数调用点

inline函数只是影响函数的执行效率，而与成员函数是否占用对象的存储空间是没有关系的

虽然成员函数并没有放在对象的存储空间中，但是从逻辑的角度来说
成员函数和数据一起封装在一个对象里面中，只允许本对象中成员函数访问同一对象中的私有数据
*/


//对象成员的引用
//在程序中经常需要访问对象的成员，访问对象的成员可以有三种方式：
/*
通过对象名和成员运算符访问对象中的成员
通过指向对象分this指针访问对象中的成员
通过对象的引用访问对象中的成员
*/


//通过对象名和成员运算符访问对象中的成员
/*
例如在程序中可以写出下列的语句
std1.num=1001
表示的是将1001复制给std1中的数据成员num。其中.是成员运算符，用来对成员进行限定
指明所访问的是哪一个对象中的成员
注意不能只写成员名而忽略了对象名，也就是说不可以这么写
num=1001
如果在程序中已经定义了一个整型变量num，则此语句意味着将1001赋值给普通变量num
如果在程序中没有另外定义普通的变量num，则就会在编译的时候出错
对象名.成员名
不仅可以在类外引用对象的公有数据成员，而且可以调用对象的公用成员函数，但是
同样需要指出对象名
不指明对象名称的话，则作为普通函数来进行处理对待

在类外只能调用公有的成员函数，在一个类中应当至少有一个公有的成员函数
作为对外的接口，否则就无法对对象进行任何的操作
*/


//通过指向对象的指针访问对象中的成员
#include<iostream>
using namespace std;
class Time
{
public:
	int hour;
	int minue;
};
Time t, *p;  //定义对象t和指针变量p
p = &t;
cout << p->hour;  //输出p指向对象中的成员的hour成员


//通过对象的引用来访问对象中的成员
/*
引用和其所代表的变量公用的是同一块内存空间
也可以为一个对象定义一个引用
代表的是同一个对=对象，只是名称不一样而已
*/


//#include<iostream>
//
////命名空间不是类型，是一个作用域
////C语言中有全局作用域和局部作用域
////定义命名空间相当于是定义了一个新的作用域
//namespace N1
//{
//	//可以定义变量，也可以定义函数
//	int a = 1;
//	int b = 2;
//	int Add(int left, int right)
//	{
//		return left + right;
//	}
//}
//
//int a = 20;  //那么如果我想要打印全局作用域中的a的话，我要怎么打印？
////printf("%d\n", ::a); 
//
//int main()
//{
//	int a = 30;
//	printf("%d\n", a);  //在这个时候调用printf函数打印的肯定是主函数中的a
//	printf("%d\n", ::a);  //::为作用域限定符，如果在一个变量前面
//	//加上了::就代表我现在访问的是全局作用域中的变量
//	printf("%d\n", N1::a);
//	//访问命名空间的a，只需要在作用域限定符的前面加上命名空间的名称就可以了
//	return 0;
//}
////三个a分别属于三个不同的作用域，所以编译起来是不会有任何问题的
////那么，在什么情况下会是有问题的？
////就是在同一个命名空间中有两个相同的变量的时候，这个时候是有问题的


//namespace N2
//{
//	int a = 10;
//	int b = 20;
//	int c = 30;
//	int Sub(int left, int right)
//	{
//		return left - right;
//	}
//	//命名空间还可以嵌套
//	namespace N3
//	{
//		int a = 10;
//		int b = 20;
//		int Mul(int left, int right)
//		{
//			return left * right;
//		}
//	}
//}
//printf("%d\n", N2::N3::a);  //在主函数中进行调用


//namespace N1   //前面已经有过N1
////如果命名空间的名字有重复的话，是否可以通过编译？
////答案是可以通过编译的
////如果存在相同名称的命名空间，编译器会把他们合并成一个
//{
//	int c = 30;
//	int d = 40;
//	int Div(int left, int right)
//	{
//		return left / right;   //保证right要不为0
//	}
//}


//using N::b;  //相当于是全局变量，如果这个时候再定义一个int b; 那么就会出错了
//int main()
//{
//	printf("%d\n", N::a);
//	printf("%d\n", b);
//}
////优点是使用方便，缺陷是容易引起冲突(上述所示，int b);
////如果冲突了，也很好解决，再变量的前面八命名空间的名称再加上就可以了。


//using namespace N;
//int main()
//{
//	printf("%d\n", N::a);
//	printf("%d\n", b);
//	Add(10, 20);
//	return 0;
//}
////使用方便，但是冲突就会多


//#include<iostream>
//using namespace std;
//int main()
//{
//	//C语言中是不会对printf函数进行语法检测的
//	//printf("%d %d %d", 10);    //编译器是不会报错的
//	//这是完全可以通过编译的，只是会有警告
//	//警告来自于后两个参数是未知的
//	//使用printf还有一个不太好的点就是
//	//要输出什么类型的数据，这个格式控制符一定要给对，而且需要我们自己来给出
//	//要记住很多种格式，很容易出错
//	//所以再C++中我们使用cout
//	cout << "change world" << endl;
//	cout << 10 << " " << 12.34 << " " << 'a' << endl;
//	//不用在乎所输出的东西的类型是什么
//	return 0;
//}


//void Test(int a = 10)   //跟的是一个默认值，好处就是主函数里面不用传参了
////如果用户再调用函数的同时进行了传参操作，那么使用的就是用户所传进去的参数
//{
//	cout << a << endl;
//}
//int main()
//{
//	Test();
//	Test(100);
//	return 0;
//}


//缺省参数的分类
//全缺省参数和半缺省参数
void TestFunc(int a = 1, int b = 2, int c = 3)
{
	//所有参数都有缺省值称为全缺省参数
	cout << a << ' ' << b << ' ' << c << ' ' << endl;
}

////半缺省参数
////void TestFunc2(int a=1,int b=2,int c)   
////无法通过编译，把b的值拿掉，也无法通过编译
////只有把a的值拿掉，才能通过编译
////a和b都拿掉，有c也是可以的
////得出规律，注意：半缺省参数只能从右往左一次给出
//void TestFunc2(int a, int b, int c = 3)  //可以通过编译
//{
//	//部分参数带有缺省值
//	cout << a << ' ' << b << ' ' << c << ' ' << endl;
//}
//int main()
//{
//	//全缺省
//	TestFunc();  //打印 1 2 3
//	TestFunc(10);  //打印 10 2 3 
//	TestFunc(10, 20);  //打印10 20 3
//	TestFunc(10, 20, 30);  //打印10 20 30
//
//	//半缺省
//	TestFunc2(10, 20);
//	TestFunc2(10, 20, 30);
//
//	return 0;
//}


//void TestFunc(int a = 20);
//
//void TestFunc(int a = 20)
//{
//
//}
////这样子的代码就会出错，原因在于如果两个位置同时来给的话，可能会给的不一样
////可能就会说不清了，给在声明的位置会比较好一些，因为有时候需要用到第三方库，要给出函数声明才能使用，而且如果定义的参数的初值不一样，编译器就会混乱；缺省参数值只能是常量或全局变量
//int main()
//{
//	return 0;
//}